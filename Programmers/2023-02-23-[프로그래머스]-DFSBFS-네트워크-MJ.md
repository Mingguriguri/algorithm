# ë„¤íŠ¸ì›Œí¬

progress: Not started
review: ğŸ¥œ
site: í”„ë¡œê·¸ë˜ë¨¸ìŠ¤
upload: No
ë“±ê¸‰: Level3
ë¦¬ë·°í•„ìš”: í•„ìš”
ë§í¬: https://school.programmers.co.kr/learn/courses/30/lessons/43162
ìœ í˜•: ë°±íŠ¸ë˜í‚¹(DFS/BFS)
ì‘ì„±ì¼ì‹œ: 2023ë…„ 2ì›” 23ì¼ ì˜¤í›„ 5:29

# ğŸ“– Problem

[í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ - ê³ ë“ì kit - DFS/BFS - ë„¤íŠ¸ì›Œí¬](https://school.programmers.co.kr/learn/courses/30/lessons/43162) (Level3)

ë„¤íŠ¸ì›Œí¬ë€ ì»´í“¨í„° ìƒí˜¸ ê°„ì— ì •ë³´ë¥¼ êµí™˜í•  ìˆ˜ ìˆë„ë¡ ì—°ê²°ëœ í˜•íƒœë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ì»´í“¨í„° Aì™€ ì»´í“¨í„° Bê°€ ì§ì ‘ì ìœ¼ë¡œ ì—°ê²°ë˜ì–´ìˆê³ , ì»´í“¨í„° Bì™€ ì»´í“¨í„° Cê°€ ì§ì ‘ì ìœ¼ë¡œ ì—°ê²°ë˜ì–´ ìˆì„ ë•Œ ì»´í“¨í„° Aì™€ ì»´í“¨í„° Cë„ ê°„ì ‘ì ìœ¼ë¡œ ì—°ê²°ë˜ì–´ ì •ë³´ë¥¼ êµí™˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë”°ë¼ì„œ ì»´í“¨í„° A, B, CëŠ” ëª¨ë‘ ê°™ì€ ë„¤íŠ¸ì›Œí¬ ìƒì— ìˆë‹¤ê³  í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì»´í“¨í„°ì˜ ê°œìˆ˜ n, ì—°ê²°ì— ëŒ€í•œ ì •ë³´ê°€ ë‹´ê¸´ 2ì°¨ì› ë°°ì—´ computersê°€ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ, ë„¤íŠ¸ì›Œí¬ì˜ ê°œìˆ˜ë¥¼ return í•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì‘ì„±í•˜ì‹œì˜¤.

**ì œí•œì‚¬í•­**

- ì»´í“¨í„°ì˜ ê°œìˆ˜ nì€ 1 ì´ìƒ 200 ì´í•˜ì¸ ìì—°ìˆ˜ì…ë‹ˆë‹¤.
- ê° ì»´í“¨í„°ëŠ” 0ë¶€í„°Â `n-1`ì¸ ì •ìˆ˜ë¡œ í‘œí˜„í•©ë‹ˆë‹¤.
- ië²ˆ ì»´í“¨í„°ì™€ jë²ˆ ì»´í“¨í„°ê°€ ì—°ê²°ë˜ì–´ ìˆìœ¼ë©´ computers[i][j]ë¥¼ 1ë¡œ í‘œí˜„í•©ë‹ˆë‹¤.
- computer[i][i]ëŠ” í•­ìƒ 1ì…ë‹ˆë‹¤.

**ì…ì¶œë ¥ ì˜ˆ**

| n | computers | return |
| --- | --- | --- |
| 3 | [[1, 1, 0], [1, 1, 0], [0, 0, 1]] | 2 |
| 3 | [[1, 1, 0], [1, 1, 1], [0, 1, 1]] | 1 |

**ì…ì¶œë ¥ ì˜ˆ ì„¤ëª…**

**ì˜ˆì œ #1**

ì•„ë˜ì™€ ê°™ì´ 2ê°œì˜ ë„¤íŠ¸ì›Œí¬ê°€ ìˆìŠµë‹ˆë‹¤.

![https://grepp-programmers.s3.amazonaws.com/files/ybm/5b61d6ca97/cc1e7816-b6d7-4649-98e0-e95ea2007fd7.png](https://grepp-programmers.s3.amazonaws.com/files/ybm/5b61d6ca97/cc1e7816-b6d7-4649-98e0-e95ea2007fd7.png)

**ì˜ˆì œ #2**

ì•„ë˜ì™€ ê°™ì´ 1ê°œì˜ ë„¤íŠ¸ì›Œí¬ê°€ ìˆìŠµë‹ˆë‹¤.

![https://grepp-programmers.s3.amazonaws.com/files/ybm/7554746da2/edb61632-59f4-4799-9154-de9ca98c9e55.png](https://grepp-programmers.s3.amazonaws.com/files/ybm/7554746da2/edb61632-59f4-4799-9154-de9ca98c9e55.png)

# ğŸ”Institution

DFSë€ ë¬´ì—‡ì¸ì§€, ì–´ë–»ê²Œ í’€ë©´ ì¢‹ì„ì§€ chatGPTì—ê²Œ ë¬¼ì–´ë³´ì•˜ë‹¤.

**chatGPT - â€œWhat is DFS?â€**

DFS stands for Depth-First Search, which is a graph traversal algorithm that starts at a given node and explores as far as possible along each branch before backtracking. The algorithm can be used to search for a path or cycle in a graph, to explore all the vertices of a graph, or to perform other graph-related tasks.

The DFS algorithm works by maintaining a stack of nodes to be visited, starting with the initial node. At each step, the algorithm removes the top node from the stack, visits it, and adds all its unvisited neighbors to the stack. This process continues until the stack is empty, meaning that all nodes in the connected component of the starting node have been visited.

DFS can be implemented recursively or iteratively, and its time complexity depends on the size of the graph and the particular implementation used. In general, DFS has a time complexity of O(V + E), where V is the number of vertices and E is the number of edges in the graph.

DFSëŠ” ê¹Šì´ ìš°ì„  ê²€ìƒ‰(Depth-First Search)ì˜ ì•½ìë¡œ, ì£¼ì–´ì§„ ë…¸ë“œì—ì„œ ì‹œì‘í•˜ì—¬ ì—­ì¶”ì  ì „ì— ê° ë¶„ê¸°ë¥¼ ë”°ë¼ ê°€ëŠ¥í•œ í•œ ë©€ë¦¬ íƒìƒ‰í•˜ëŠ” ê·¸ë˜í”„ íŠ¸ë˜ë²„ì„¤ ì•Œê³ ë¦¬ì¦˜ì´ë‹¤. ì´ ì•Œê³ ë¦¬ì¦˜ì€ ê·¸ë˜í”„ì—ì„œ ê²½ë¡œë‚˜ ì‚¬ì´í´ì„ ê²€ìƒ‰í•˜ê±°ë‚˜, ê·¸ë˜í”„ì˜ ëª¨ë“  ì •ì ì„ íƒìƒ‰í•˜ê±°ë‚˜, ë‹¤ë¥¸ ê·¸ë˜í”„ ê´€ë ¨ ì‘ì—…ì„ ìˆ˜í–‰í•˜ëŠ” ë° ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

DFS ì•Œê³ ë¦¬ì¦˜ì€ ì´ˆê¸° ë…¸ë“œë¶€í„° ì‹œì‘í•˜ì—¬ ë°©ë¬¸í•  ë…¸ë“œì˜ ìŠ¤íƒì„ ìœ ì§€ ê´€ë¦¬í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ì‘ë™í•©ë‹ˆë‹¤. ê° ë‹¨ê³„ì—ì„œ ì•Œê³ ë¦¬ì¦˜ì€ ìŠ¤íƒì—ì„œ ìµœìƒìœ„ ë…¸ë“œë¥¼ ì œê±°í•˜ê³ , ì´ ë…¸ë“œë¥¼ ë°©ë¬¸í•˜ê³ , ë°©ë¬¸í•˜ì§€ ì•Šì€ ëª¨ë“  ì¸ì ‘ ë…¸ë“œë¥¼ ìŠ¤íƒì— ì¶”ê°€í•©ë‹ˆë‹¤. ì´ í”„ë¡œì„¸ìŠ¤ëŠ” ìŠ¤íƒì´ ë¹„ì›Œì§ˆ ë•Œê¹Œì§€ ê³„ì†ë©ë‹ˆë‹¤. ì¦‰, ì‹œì‘ ë…¸ë“œì˜ ì—°ê²°ëœ êµ¬ì„± ìš”ì†Œì— ìˆëŠ” ëª¨ë“  ë…¸ë“œë¥¼ ë°©ë¬¸í–ˆìŠµë‹ˆë‹¤.

DFSëŠ” ì¬ê·€ì ìœ¼ë¡œ ë˜ëŠ” ë°˜ë³µì ìœ¼ë¡œ êµ¬í˜„ë  ìˆ˜ ìˆìœ¼ë©°, ì‹œê°„ ë³µì¡ì„±ì€ ê·¸ë˜í”„ì˜ í¬ê¸°ì™€ ì‚¬ìš©ëœ íŠ¹ì • êµ¬í˜„ì— ë”°ë¼ ë‹¬ë¼ì§„ë‹¤. ì¼ë°˜ì ìœ¼ë¡œ DFSëŠ” O(V + E)ì˜ ì‹œê°„ ë³µì¡ë„ë¥¼ ê°€ì§€ë©°, ì—¬ê¸°ì„œ VëŠ” ì •ì ì˜ ìˆ˜ì´ê³  EëŠ” ê·¸ë˜í”„ì˜ ëª¨ì„œë¦¬ì˜ ìˆ˜ì´ë‹¤.

**When implementing DFS in code, the typical order of operations is:**

1. Initialize a visited set or array to keep track of which nodes have been visited.
2. Create a stack or use the system call stack to keep track of the nodes to be explored.
3. Add the starting node to the stack and mark it as visited.
4. While the stack is not empty, pop the top node from the stack.
5. For each unvisited neighbor of the popped node, mark it as visited and add it to the stack.
6. Repeat steps 4 and 5 until the stack is empty.

ì½”ë“œì—ì„œ DFSë¥¼ êµ¬í˜„í•  ë•Œ ì¼ë°˜ì ì¸ ì‘ì—… ìˆœì„œëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤:

1. ë°©ë¬¸í•œ ë…¸ë“œë¥¼ ì¶”ì í•˜ê¸° ìœ„í•´ ë°©ë¬¸í•œ ì„¸íŠ¸ ë˜ëŠ” ì–´ë ˆì´ë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.

2. ìŠ¤íƒì„ ë§Œë“¤ê±°ë‚˜ ì‹œìŠ¤í…œ í˜¸ì¶œ ìŠ¤íƒì„ ì‚¬ìš©í•˜ì—¬ íƒìƒ‰í•  ë…¸ë“œë¥¼ ì¶”ì í•©ë‹ˆë‹¤.

3. ì‹œì‘ ë…¸ë“œë¥¼ ìŠ¤íƒì— ì¶”ê°€í•˜ê³  ë°©ë¬¸ìœ¼ë¡œ í‘œì‹œí•©ë‹ˆë‹¤.

4. ìŠ¤íƒì´ ë¹„ì–´ ìˆì§€ ì•Šì€ ìƒíƒœì—ì„œ ìŠ¤íƒì˜ ë§¨ ìœ„ ë…¸ë“œë¥¼ íŒí•©ë‹ˆë‹¤.

5. íŒì—…ëœ ë…¸ë“œì˜ ë°©ë¬¸ë˜ì§€ ì•Šì€ ê° ì¸ì ‘ ë…¸ë“œì— ëŒ€í•´ ë°©ë¬¸ë¨ìœ¼ë¡œ í‘œì‹œí•˜ê³  ìŠ¤íƒì— ì¶”ê°€í•©ë‹ˆë‹¤.

6. ìŠ¤íƒì´ ë¹„ì›Œì§ˆ ë•Œê¹Œì§€ 4ë‹¨ê³„ì™€ 5ë‹¨ê³„ë¥¼ ë°˜ë³µí•©ë‹ˆë‹¤.

# ğŸ”Approach

DFS - Stack

[ 1, 1, 0 ]

[ 1, 1, 0 ]

[ 0, 0, 1 ]

ië²ˆì§¸ computerì˜ ië²ˆì§¸ ê°’ì€ ë¬´ì¡°ê±´ 1ì´ ë˜ì–´ì•¼ í•¨ (ëŒ€ê°ì„±ë¶„ì˜ ê°’ì€ í•­ìƒ 1)

ë”°ë¼ì„œ ë³¼ ë•Œ if ë¬¸ìœ¼ë¡œ ë´ì•¼ í•¨

ië²ˆì§¸ computerì—ì„œ iì´ì™¸ì˜ ì¸ë±ìŠ¤ì˜ ê°’ì´ 0ì´ë©´ ì—°ê²°ì´ ë˜ì§€ ì•Šì€ ê²ƒì´ê³  1ì´ë©´ ì—°ê²°ë˜ì–´ ìˆëŠ” ê²ƒì´ë‹¤.

ií–‰ë³„ë¡œì˜ sumê°’ì´ 1ì¼ ë•Œ anwer+=1 í•œë‹¤. ë§ˆì§€ë§‰ì— returní•  ë•ŒëŠ” answerì— +1í•œ ê°’ì„ returní•œë‹¤.

**computers**

| i / j | 0 | 1 | 2 |
| --- | --- | --- | --- |
| 0 | 1 | 1 | 0 |
| 1 | 1 | 1 | 0 |
| 2 | 0 | 0 | 1 |

computers[i][j] == 1 and i != j

stack.append([i,j])

**stack**

- appendí•  ê²ƒ: ë…¸ë“œì˜ ì¸ë±ìŠ¤ ê°’
- popí•œ ê°’ì„ ë°©ë¬¸ë…¸ë“œë¡œ ì§€ì •í•œë‹¤.
- ì–¸ì œ pop? : ìŠ¤íƒì˜ ê°’ì´ ìˆìœ¼ë©´ popí•œë‹¤.
- neighborì— ìˆëŠ” indexë¥¼ append ì´ê²ƒì„ ë°˜ë³µ ë‹¤ ë³¼ ë•Œê¹Œì§€ ë°˜ë³µí•¨

stack = [0]

visited = [False] * n #ë°©ë¬¸ì—¬ë¶€ í™•ì¸ ğŸ˜€

## ğŸš©My submission

```python
def solution(n, computers):
    answer = 0
    visited = [False] * n
    stack = []
    for i in range(n):
        if visited[i] == False:
            stack.append(i)
            answer += 1

        while stack:
            i = stack.pop()
            visited[i] = True

            for j in range(n):
                if computers[i][j] == 1 and i != j:
                    if visited[j] == False:
                        stack.append(j)
    return answer
```

## ğŸš©Others submission

```python
def solution(n, computers):
    answer = 0      
    pNode = [False] * n
    stack = []
    for i in range(n):
        if pNode[i] == False:
            answer += 1
            stack.append(i)

        while stack:
            value = stack.pop()
            pNode[value] = True

            for j in range(n):
                if j != value and computers[value][j] and not pNode[j]:
                    stack.append(j)

    return answer
```

```python
def solution(n, computers):
    answer = 0      
    pNode = [False] * n
    
    def dfs(node):
        nonlocal pNode
        nonlocal computers
        
        if pNode[node] == True:
            return
        pNode[node] = True
        for i in range(n):
            if pNode[i] == False and computers[node][i]:
                dfs(i)
    
    for k in range(n):
        if pNode[k] == False:
            dfs(k)
            answer += 1
                
    return answer
```

# ğŸ’¡TIL